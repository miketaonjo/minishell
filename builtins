///CD
char	*ft_getcwd(char *buf, size_t size)
{
	char	*pwd;

	pwd = getcwd(buf, size);
	if (pwd == NULL)
		exit_with_err("getcwd()", strerror(errno), EXIT_FAILURE);
	return (pwd);
}

char	*get_pwd_key_value(const char *key)
{
	char	*tmp;
	char	*pwd_key_value;

	tmp = ft_getcwd(NULL, 0);
	pwd_key_value = ft_strjoin(key, tmp);
	free(tmp);
	return (pwd_key_value);
}

void	export_pwd(const char *pwd, t_env *env_head)
{
	char	*tmp_pwd;

	tmp_pwd = get_pwd_key_value(pwd);
	export_key_value(env_head, tmp_pwd);
	free(tmp_pwd);
}

static int	cd_home(char *path, t_env *env_head)
{
	int		exit_code;
	char	*home;
	char	*tmp_pwd;

	exit_code = EXIT_FAILURE;
	home = ft_getenv(env_head, "HOME");
	if (home == NULL)
		print_err2("cd", "home not set");
	else
	{
		tmp_pwd = get_pwd_key_value("OLDPWD=");
		exit_code = chdir(home);
		if (exit_code == -1)
			print_err3("cd", path, strerror(errno));
		else
			export_key_value(env_head, tmp_pwd);
		free(tmp_pwd);
	}
	if (exit_code != -1)
		export_pwd("PWD=", env_head);
	return (exit_code);
}

static int	cd_tilde(t_env *env_head)
{
	int		exit_code;
	char	*home;
	char	*tmp_pwd;

	exit_code = EXIT_FAILURE;
	home = getenv("HOME");
	if (home == NULL)
		print_err2("cd", "home not set");
	else
	{
		tmp_pwd = get_pwd_key_value("OLDPWD=");
		exit_code = chdir(home);
		if (exit_code == -1)
			print_err3("cd", home, strerror(errno));
		else
			export_key_value(env_head, tmp_pwd);
		free(tmp_pwd);
	}
	if (exit_code != -1)
		export_pwd("PWD=", env_head);
	return (exit_code);
}

static int	cd_tilde_path(char *path, t_env *env_head)
{
	int		exit_code;
	char	*home;
	char	*tmp_pwd;
	char	*home_path;

	exit_code = EXIT_FAILURE;
	home = getenv("HOME");
	if (home == NULL)
		print_err2("cd", "home not set");
	else
	{
		tmp_pwd = get_pwd_key_value("OLDPWD=");
		home_path = ft_strjoin(home, path + 1);
		exit_code = chdir(home_path);
		if (exit_code == -1)
			print_err3("cd", home_path, strerror(errno));
		else
			export_key_value(env_head, tmp_pwd);
		free(home_path);
		free(tmp_pwd);
	}
	if (exit_code != -1)
		export_pwd("PWD=", env_head);
	return (exit_code);
}

static int	cd_path(char *path, t_env *env_head)
{
	int		exit_code;
	char	*tmp_pwd;

	exit_code = EXIT_FAILURE;
	tmp_pwd = get_pwd_key_value("OLDPWD=");
	exit_code = chdir(path);
	if (exit_code == -1)
		print_err3("cd", path, strerror(errno));
	else
		export_key_value(env_head, tmp_pwd);
	free(tmp_pwd);
	if (exit_code != -1)
		export_pwd("PWD=", env_head);
	return (exit_code);
}

int	ft_cd(char *path, t_env *env_head)
{
	if (path == NULL)
		return (cd_home(path, env_head));
	else if (!ft_strcmp("~", path))
		return (cd_tilde(env_head));
	else if (!ft_strncmp("~/", path, 2))
		return (cd_tilde_path(path, env_head));
	else
		return (cd_path(path, env_head));
}

//ECHO
static int	is_option_n(char *str)
{
	if (str == NULL)
		return (0);
	if (ft_strncmp(str, "-n", 2))
		return (0);
	++str;
	while (*str == 'n')
		str++;
	if (*str != 0)
		return (0);
	return (1);
}

static int	check_option_n(int argc, char *argv[], int *idx)
{
	int	i;
	int	option_n;

	i = 1;
	option_n = 0;
	if (argc == 1)
		return (0);
	option_n = is_option_n(argv[i]);
	while (i < argc && is_option_n(argv[i]))
		++i;
	*idx = i;
	return (option_n);
}

int	ft_echo(int argc, char *argv[])
{
	int	idx;
	int	option_n;

	idx = 1;
	option_n = check_option_n(argc, argv, &idx);
	while (idx < argc && argv[idx])
	{
		ft_write(STDOUT_FILENO, argv[idx], ft_strlen(argv[idx]));
		if (idx + 1 != argc)
			ft_write(STDOUT_FILENO, " ", 1);
		++idx;
	}
	if (option_n == 0)
		ft_write(STDOUT_FILENO, "\n", 1);
	return (EXIT_SUCCESS);
}

//ENV
int	ft_env(t_env *cur)
{
	while (cur->key != 0)
	{
		ft_write(STDOUT_FILENO, cur->key, ft_strlen(cur->key));
		ft_write(STDOUT_FILENO, "=", 1);
		ft_write(STDOUT_FILENO, cur->value, ft_strlen(cur->value));
		ft_write(STDOUT_FILENO, "\n", 1);
		cur = cur->next;
	}
	return (EXIT_SUCCESS);
}

//EXIT
static int	is_all_number(char *str)
{
	while (*str)
	{
		if (!ft_isdigit(*str) && !ft_isspace(*str))
			return (0);
		str++;
	}
	return (1);
}

static void	exit_no_arg(t_cmd *cmd)
{
	int	exit_code;

	exit_code = EXIT_SUCCESS;
	if (cmd->prev == NULL)
		ft_write(STDOUT_FILENO, "exit\n", 5);
	exit(exit_code);
}

static void	exit_two_arg(t_cmd *cmd)
{
	int	exit_code;

	exit_code = EXIT_SUCCESS;
	if (cmd->prev == NULL)
		ft_write(STDOUT_FILENO, "exit\n", 5);
	if (!is_all_number(cmd->argv[1]))
	{
		print_err3("exit", cmd->argv[1], "numeric argument required");
		exit_code = 255;
	}
	else
		exit_code = ft_atoi(cmd->argv[1]) % 256;
	exit(exit_code);
}

int	ft_exit(t_cmd *cmd)
{
	int	exit_code;

	exit_code = EXIT_SUCCESS;
	if (cmd->argc == 1)
		exit_no_arg(cmd);
	if (cmd->argc == 2)
		exit_two_arg(cmd);
	if (cmd->argc > 2)
	{
		if (!is_all_number(cmd->argv[1]))
			exit_code = 255;
		if (cmd->prev == NULL && exit_code == 255)
		{
			ft_write(STDOUT_FILENO, "exit\n", 5);
			print_err3("exit", cmd->argv[1], "numeric argument required");
			exit(exit_code);
		}
	}
	ft_write(STDOUT_FILENO, "exit\n", 5);
	print_err3("exit", NULL, "too many arguments");
	return (0);
}

//PWD
int	ft_pwd(void)
{
	char	*pwd;

	pwd = getcwd(NULL, 0);
	ft_write(STDOUT_FILENO, pwd, ft_strlen(pwd));
	ft_write(STDOUT_FILENO, "\n", 1);
	free(pwd);
	return (EXIT_SUCCESS);
}


//UNSET
static void	remove_env(t_env *env)
{
	t_env	*next;
	t_env	*prev;

	next = env->next;
	prev = env->prev;
	prev->next = env->next;
	next->prev = env->prev;
	free(env->key);
	free(env->value);
	free(env);
}

static int	check_valid_key_identifier(int argc, char *argv[])
{
	int	i;
	int	ret;

	i = 0;
	ret = 0;
	while (++i < argc)
	{
		if (argv[i] == NULL)
		{
			print_quote_err3("unset", "", "not a valid identifier");
			return (-1);
		}
		if (is_have_specific_char(argv[i], '='))
			ret = -1;
		else if (is_have_space(argv[i], '\0'))
			ret = -1;
		else if (is_all_digit(argv[i], '\0'))
			ret = -1;
		if (ret == -1)
		{
			print_quote_err3("unset", argv[i], "not a valid identifier");
			return (ret);
		}
	}
	return (0);
}

static void	unset(t_env *env_head, char *key)
{
	t_env	*env;

	env = compare_env_key(env_head, key);
	if (env->key == NULL)
		return ;
	else
		remove_env(env);
}

int	ft_unset(int argc, char *argv[], t_env *env_head)
{
	int	i;

	if (argc < 2)
		return (EXIT_SUCCESS);
	if (check_valid_key_identifier(argc, argv) == -1)
		return (EXIT_FAILURE);
	i = 1;
	while (i < argc)
	{
		unset(env_head, argv[i]);
		++i;
	}
	return (EXIT_SUCCESS);
}
